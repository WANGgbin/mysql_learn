mysql 里面的 undo_log 主要用于事务回滚和 mvcc(快照读)。

- undo log 日志格式？

    undo log 没有必要保存记录全部的信息，只需要保留一部分信息，只要能根据这部分信息能得到之前记录的全部内容即可。不同的操作在 undo log 中要保留的信息不同。

    - insert

        插入一条新的记录，undo log 只需要保留主键即可。

    - delete

        注意这里的删除仅仅是加一个删除标记，即软删除。目的是为了支持 mvcc。delete 的 undo log 除了记录主键信息外，还需要保存各个二级索引列的信息。二级索引列的信息主要用于在 purge 阶段真正删除数据的时候定位二级索引中记录的位置。

    - update

        update 语句稍微复杂一些，根据是否更新主键，是否为原地更新对应多种可能。

        - 不更新主键 

            - 原地更新

                记录一条 update undo log, undo log 中记录主键信息、所有更新的列的信息、所有更新的二级索引信息(用于回滚二级索引中对应的记录)。

            - 非原地更新

                物理删除旧的记录，插入新的记录。为什么要物理删除呢？想一下同一个主键同时存在两条记录，这是不是很奇怪。

        - 其他场景

            其他场景，需要软删除旧的记录，并插入一条新的记录。软删除旧的记录对应一条 delete undo log，插入新的记录对应一条 insert undo log. 总共对应两条日志。

- undo log 在磁盘上是如何存储的？

    几个关键的原则。
    - 同一个事务对应的所有的 undo log 会分为两类：插入类型 undo log; 其他类型.

        为什么要分成两类？我们知道插入类型 undo log 在事务提交后，便可以直接删除。而其他类型的日志，还用于 mvcc，因此不能直接删除。因此我们把这两类 undo log 做一个分类，方便管理。

    - 同一个事务同一类型的 undo log 组成一个页链表。

        为什么要组成一个链表？通过遍历链表，即可遍历全部的 undo log.

    - 一个页链表由一个单独的段分配

        一个页链表对应一个单独的段，从该段中分配链表需要的所有的页。至于原因就是让 undo log 所在的页尽可能的近，从而在回滚的时候尽量减少随机 I/O 带来的影响，提高系统性能。

    - 一个回滚段目前只包含一个页，页中包含 1024 个 undo slot, 每个 undo slot 存储每一个页链表的首页页号。
    - 系统包含 128 个回滚段，在表空间的第 5 页中存储这个 128 个回滚段对应的页的表空间 + 页号， 这意味着不同的回滚段可以在不同的表空间中。实际上，undo log 默认都在系统表空间中，不过可以通过配置的方式将 undo log 存储到 undo 专属的表空间中。
    - undo log 涉及的两种段

        undo log 涉及到两种类型的段，一种是用于真正存储 undo log 的段；另一种则是用于管理存储 undo log 段的段，通过该段便可以访问系统中全部的 undo log。主要用于系统宕机后的恢复。

- 为什么二级索引没有对应的 undo log ？

    实际上，所有的增删改对应的 undo log 都是相对于聚簇索引上的记录而言。为什么二级索引没有对应的 undo log 呢？ 实际上我们通过聚簇索引的 undo log 恢复旧的记录后，便可根据修改的二级索引恢复所有的二级索引。

- undo log 是在什么时候删除的？

    既然 delete 操作仅仅是软删除，那么这些加了软删除标记的记录是什么时候删除的呢？另外用于 mvcc 的 undo log 是什么时候真正删除的呢？

    一个原则是：**如果一个事务在系统中最早的 read view 看来是提交的，那么该事务对应的 undo log 就可以删除，同样，该事务加了软删除标记的记录也可以删除**。
    每一个回滚段对应一个 history 链表，histroy 链表中每个节点就是某个事务对应的 undo 页链表。当事务提交后，系统会给事务分配一个 no，用来表示事务的提交顺序。
    事务在创建 read view 的时候，会存储当前系统中最大的 no + 1, 同时系统会按照时间顺序，将所有的 read view 串联起来。

    系统中有一个 purge 线程，该线程会遍历所有的 histroy 链表，然后判断每个节点对应的 no 是否小于 read view 链表中首节点中存储的 no， 若是，则删除 history 中该节点对应的所有 undo log， 同时会判断是否有 delete 类型的 undo log，如果有，会同时删除对应加了软删除标记的日志。

    这里注意一个小技巧，系统会在页链表的首页中，存储该页链表中是否有 delete 类型的日志，如果没有，则直接删除所有的 undo log，如果有，则需要遍历所有的 undo log，找出所有的 delete 类型 undo log 并删除加了软删除标记的记录，最后再删除所有的 undo log. **这实际上是一种 fast-slow 的思想，大多数时候可以命中 fast，从而提高系统性能**。

    这里还需要注意一个问题，因为 purge 是按照系统最早的 read view 来判断是否删除 undo log. 如果在 repeatable read 级别下，如果一个大事务一直没有提交，就会导致表空间越来越大，记录的版本链越来越长，从而影响系统性能。**这也是我们要尽量避免大事务的原因之一**。

- 系统异常宕机重新开机后，如何根据 undo log 恢复数据？

    从系统表空间的第 5 页开始，遍历所有的回滚段。对于每一个回滚段，遍历每一个 undo slot, 对于每一个 undo slot 判断 undo 的状态，如果是未完成，则会进行回滚操作。