描述 mysql 中是如何执行一条查询语句的。

## 单表查询

存在多种方式来执行一条针对单表的查询，我们来看看都有哪些查询方式以及各自的使用场景。

- const

    如果是**主键/唯一二级索引**的**常量等值**比较， 则最多只存在一条满足条件的记录，这种查询方式成为 const。

- ref

    **非唯一二级索引的常量等值**比较，只会有一个单点扫描区间，这种查询方式称为 ref.

- ref_or_null

    非唯一二级索引常量等值比较 或者是 IS NULL 比较，这种方式称为 ref_or_null. 在 ref 基础上多了一个跟 NULL 的比较。

- range

    当存在多个单点扫描区间(IN(x,x,x))或者是索引的范围查找的时候， 这种方式称为 range.

- index_merge

    通常单表查询只涉及一个索引， 但有时候会同时访问多个索引。 index_merge 分为：
    - intersection_index_merge
    - union_index_merge
    - sort_union_index_merge
    
    之所以合并索引的目的是为了减少回表的次数. 各个 index_merge 的含义可以参考《Mysql是怎样运行的》P173.

- index

    有时候，通过扫描某个索引列的全部记录即可查询到相应的信息。因为二级索引叶子页面只存储 **索引列 + 主键**, 因此一个页中可以存储更多的记录， 因此相比于全表扫描而言，性能会更好一些。

- all

    all 即全表扫描。这是最慢的方式。

## 多表 join 查询

多表查询即多表的 join 查询。那么多表的 join 查询流程是什么样的呢？我们这里重点描述两表 join 的查询方式。

当 server 确定好驱动表和被驱动表之后，常见的查询方式有：

- 基于索引的嵌套循环

    首先在驱动表中找到第一条符合条件的记录，此时，对于被驱动表而言， 其所有的查询条件便确定了，再对被驱动表进行一次单表查询即可。如果在对被驱动表进行单表查询的时候能够使用索引的方式，则可以大大提高连接查询的性能。我们把使用索引方式查询被驱动表的方式称为**基于索引的嵌套循环**。
    因此，**在我们编写连接查询的时候，应该尽可能的让被驱动表使用到索引，比如在 ON 子语句中 通过被驱动表的索引字段进行等值比较。**
    
- 基于块的嵌套循环

    当被驱动表无法使用索引的时候，只能通过全表扫描的方式查询。但是，对于驱动表中每一条符合条件的记录，都需要遍历被驱动表中的所有记录，如果被驱动表中数据足够多的话，就会出现磁盘页的频繁换入/换出。因此，一种优化方式是，首先在内存中申请一块儿内存(join buffer)， 然后让驱动表中符合条件的记录塞满这块内存，然后再遍历被驱动表中的所有记录，跟 join buffer 中的所有记录都进行比较，这样便能缓解磁盘页的换入/换出次数，以前是匹配驱动表中的每条记录时都进行换入/换出，但是现在只有 join buffer 塞满后，才进行一次换入/换出。

    这里需要注意的时候，我们在查询语句中尽量避免使用 *， 而是指明需要的具体字段， 这样 join buffer 中可以存储更多的记录， 从而进一步提高性能。

    我们把这种基于 join buffer 的查询方式称为 **基于块的嵌套循环**。

## 成本分析

- 为什么要进行成本分析

    比如单表扫描，可能存在多种查询方式， 我们怎么知道应该使用哪一种查询方式呢？ 又比如，多表连接查询的时候， 怎么判断应该使用哪个表作为驱动表，哪个作为被驱动表呢？这就涉及到成本分析。
    在 server 中，有个优化器的组件，优化器的作用就是进行成本分析，然后生成最终的执行计划，再调用存储引擎的接口来完成真正的 sql 操作。

- 怎么进行成本分析

    那么怎么进行成本分析呢？成本就两个方面。
    - I/O 成本

        我们知道对于 InnoDB 而言，数据时存储在磁盘页上的。当把磁盘页加载到内存中的时候，就涉及 I/O， mysql 规定一个页的加载的成本常数为 1.0. 

    - CPU 成本

        当加载一个磁盘页到内存后，接着需要从页中查询记录并判断记录是否满足查询条件， 这一步的成本常数为 0.2.

    整个成本分析，就包括这两方面。查询涉及多少个磁盘页，涉及多少记录。然后计算最终的成本，然后从各种查询方式中选择成本最小的方式。

    这里有个问题，我们怎么知道有多少磁盘页， 多少记录呢？ 为了获取这些信息，难道要真正查询一次数据吗？ 当然不是，如果这样的话， 成本分析的成本也太高了。那怎么获取这些信息呢？

- 磁盘页计算

    如果是全表扫描，就需要统计全部的页。这就涉及到表的统计信息，这一部分内容我们在 stats.md 中描述。
    反之，我们首先定位到第一条记录所在的页， 再定位最后一条记录所在的页，然后判断页所在的目录项是否在同一个页，如果在同一个页，则可以计算出之间有多少页， 如果不在同一个页，则继续递归。因为 B+ 树树高通常不会高于 4 层， 所以这种方式并不会影响性能。

- 记录计算
    同样如果是全表扫面，全表有多少记录时维护在表的统计信息中的。反之，当我们确定了第一条记录到最后一条记录之间的页面数量的时候，然后采样头几个页面来计算每个页面的平均记录数量，然后再乘以页面的总数，便可以得到记录数。
    那么应该采样多少页面呢？默认是采样 10 个页面，因此如果页面的数量小于等于 10， 那么得到的记录就是精确的，否则就是估算。

    如果，我们通过 IN 指定了很多的单点扫描区间，如果使用前面所述的方式来统计每个单点扫描区间的记录数，这个成本也是很客观的。那么怎么办呢？这个时候就会使用索引的统计信息进行估算。索引的统计信息中有一项是 `Cardinality` 即该列的不重复值的数量，结合表统计中的`n_rows`便可计算出索引一条记录对应多少条用户记录，再乘以 IN 中指定的单点扫描区间的数量，即可得到总的记录数。
