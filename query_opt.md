描述 mysql 中的查询优化。

## 外连接优化


## IN 子查询优化 

子查询指的是在 select 内部又嵌套了 select， 我们把内部的 select 称为子查询，外部的称为外层查询。子查询可以出现在外层查询的任意地方，我们这里重点关注出现在外层查询 where 语句之后的 IN 子查询，其语法为：
```sql
    select * from outer_table where outer_expr in (select inner_expr from inner_table where condition);
```

我们根据子查询是否依赖外层查询将子查询分为相关子查询、不相关子查询。那么子查询到底是如何执行的呢？我们通常认为是这样运行的。

- 不相关子查询

    首先查询子查询得到一个结果集，然后再查询外层查询，判断每一条记录是否匹配子查询的结果集，如果匹配，则返回给用户。

- 相关子查询

    首先查询外层查询，对于外层查询的每一条记录，结合依赖条件去查询子查询等到一个结果集，然后再判断外层记录是否满足子查询结果集，如果满足，则返回给用户。

那么子查询真的是这么运行的吗？

实际上，上述查询方法都需要建立一个结果集，本质上就是一个临时表，我们把建立临时表的这个动作称之为 **物化**，把建立的临时表称为 **物化表**。物化是有性能代价的，实际上，在 server 优化器实现中，并非总是选择物化，**而是能避免物化尽量避免物化，能走索引就走索引，这就是 子查询优化的本质。** 怎么理解呢？

实际上，IN 子查询跟内连接是很相似的， 比如上面 IN 子查询对应的内连接为：
```sql
    select outer_table.* from outer_table inner join inner_table on outer_expr == inner_expr where condition.
```

很相似但不是一致，因为如果对于 outer_table 中的某一条记录，可能同时在 inner_table 中存在多条记录，这就导致内连接的结果比 IN 子查询的结果多。如果在 inner_table 最多只存在一条记录，则内连接的结果跟 IN 子查询的结果是完全一样的。

在 mysql 中，我们引入了 **半连接** 的概念，将 s1 表和 s2 表进行半连接的意思就是：对于 s1 表中的某条记录来说，我们不关心 s2 表中存在多少条记录，我们只关心 s2 表中是否存在匹配的记录，最终的结果集中也保留 s1 表的内容。

说了这么多，半连接跟 IN 子查询优化有什么关系呢？

实际上，如果某个子查询可以转化为半连接，我们就避免了 **物化** 的过程，从而能够提高查询性能。接下来，我们分别讨论下，mysql 中针对 IN 子查询几种不同的优化方式。

- table pullout (子查询表上移)

    如果 IN 子查询的 inner_expr 是主键或者唯一二级索引，此时可以 IN 子查询完全等价的转化为内连接，然后可以使用内连接的优化方式(根据成本选择驱动表/被驱动表)来执行查询。

- duplicate weedout (重复值移除)

    我们仍然可以将 IN 子查询转化为一个内连接，并按照内连接的优化方式来执行查询。这不过此时需要去重，我们可以建立一个临时表(仅有一个字段，类型同外层表主键)，当我们执行内连接查询到一条符合条件的记录后，首先判断外层表的主键是否在这个临时表中存在，如果不存在，则将这条记录存下来，作为结果返回给用户。

- loose scan (松散扫描)

    如果对于子查询表而言可以使用到某个二级索引而且查询列表刚好是该二级索引的话(**二级索引是有序的，完美的适用于去重场景**)，则可以以内部表为驱动表，只对每一个二级索引值对应的第一行记录匹配外部表。

- first match (首次匹配)

    先取外层表的一条记录，然后匹配内部表，成功匹配第一条记录后，停止匹配。注意这种方式跟 duplicate weedout 的区别。 duplicate weedout 是通过内连接的方式执行，驱动表可以是任意的，但是 first match 只能从外部表开始查。

当然，**并不是所有的 IN 子查询都可以转化为半连接**。详细场景不再列举，总而言之，凡是能通过类似 join 的方式直接查询到结果的，则可以使用上述方式来优化 IN 子查询。

那么不能转化为半连接的 IN 子查询有优化方式吗？有的。
- 物化

    先将子查询结果物化，然后对外部表和物化表进行一次内部 join 即可。但是注意，这种方式只适用于 不相关子查询。

- 转化为 EXISTS 语句

    为什么要转化为 EXISTS 语句， 目的是为了尽可能的利用索引。如果转化为 EXISTS 语句后，可以使用到索引，则会尝试使用该方法。主要用于相关子查询。
    比如：
    ```sql
        -- s2 在 key3 上有索引
        select * from s1
            where key1 in (select key3 from s2 where s1.common_field = s2.common_field)
            or key2 > 1000
    ```
    上述方式在查询 s2 的时候，是无法使用到索引的。但是如果我们转化为下面的 EXISTS 语句：
    ```sql
        select * from s1
            where exists (select 1 from s2 where s1.common_field = s2.common_field and s1.key1 = s2.key3)
            or key2 > 1000
    ```
    上述语句在查询 s2 的时候，是可以利用 s2 的索引 key3 的。

综上，我们可以看到 IN 子查询的优化原则就是：能不物化就不物化，能走索引就走索引。

## 派生表优化

我们把 from 子查询生成的表称为派生表，那么对于 from 子查询又是如何优化的呢？
- 物化

    首先将 from 子查询结果写入到一个临时表中，再对该临时表进行查询。

- 跟外层查询合并

    有的时候，from 子查询可以跟外部查询直接合并。