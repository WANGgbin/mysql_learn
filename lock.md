本文介绍 Innodb 中的锁。

# 表级锁

## MDL

MDL(MetaData Lock) 即元数据锁，该锁是在 mysql server 层中实现的一个锁，用来保护表元数据。ddl 语句会加 MDL 的互斥锁，而普通的 sql 语句都会加 MDL 的共享锁。

## IX/IS

IX 意向互斥锁，当要加记录的互斥锁的时候，就会加一个表级别的 IX 锁。
IS 意向共享锁，当要加记录的共享锁的时候，就会加一个表级别的 IS 锁。

那么 IX/IS 存在的意义是什么呢？

当我们要加表级别的共享锁的时候，我们需要确保当前表中没有记录的 X 锁，怎么判断呢？遍历吗？
当我们要加表级别的互斥锁的时候，我们需要确保当前表中没有记录的 X 锁 和 S 锁，怎么判断呢？遍历吗？

这就是 IX/IS 的作用，只需要判断当前表是否有 IX/IS，即可知道，当前表是否存在行维度的锁，提高了系统整体性能。

## AUTO_INC 锁

当表中有 AUTO_INCREMENT 字段，在插入数据的时候，就需要占据该锁获取新的值。

# 行锁

行锁是存储引擎维度的锁，**并不是所有的存储引擎都支持行锁**。

## record 锁

如果只对某条记录加锁，这就是 record 锁，有共享锁/互斥锁两种类型。

## gap 锁

gap 锁指的是对两条记录之间的区域加一个锁，禁止在该区域插入新的数据。需要特别注意的是，**即使某个事务加了 gap 锁，另一个事务还是可以加 gap 锁的， gap 锁存在的意义仅仅是为了避免插入新的数据，彼此之间是没有互斥性的**。

那么这个特殊的锁用于什么目的呢？禁止插入新的数据？为什么要禁止插入新的数据呢？ 为了解决 **幻读**。

## next-key 锁

next-key 锁就是 record 锁 + gap 锁。

## 隐式锁

生成锁/管理锁是有成本的。因此能不生成就不生成。在插入场景下，新插入的记录并不会生成锁，当其他事务获取这条记录的锁的时候，会通过这条记录的 trx_id 判断对应的事务是否已经提交，如果没有，则会为这个未提交的事务生成一个 X record 锁，然后再自己生成一个 X record 锁。这就是隐式锁的含义。

## 插入意向锁

如果插入位置存在 gap 锁，则会生成一个插入意向锁。这样当 gap 锁释放的时候，就会激活阻塞在插入意向锁上的线程，继续后续的操作。

# 不同隔离级别加锁行为分析

我们看看不同隔离级别下是怎么加锁的。不仅仅是锁定读语句，增、删、改语句在操作记录前，都有一个与锁定读语句类似的锁定的过程，而锁定的过程就是加锁的过程。<br>

要想明白加锁的流程，前提要搞清楚 mysql 查找 record 的流程。大致流程如下：
- 根据查询条件 以及 索引 确定扫描区间。
- 遍历每一个扫描区间，查找目标数据。

## 读提交

读提交隔离级别，主要避免不可重复读的问题。因此，会对扫描区间中所有符合条件的记录都加 record 锁，至于扫描区间中不符合条件的记录是不会加锁的，因此其他的事务可以修改这些记录，导致事务在下次以相同的条件锁定记录的时候可以得到新的记录，这就是幻读。

## 可重复读

对于可重复读，我们需要理解两个概念：
- 扫描区间第一条记录
- 扫描区间后一条记录

加锁，就是加这两条记录以及区间之间的 next key 锁，如果从二级索引开始查找，当二级索引记录满足条件的时候，还会回表，对一级索引中的记录加 X record 锁。如果二级索引记录不满足查找索引下推条件，则是没必要回表的。gap 锁避免了其他事务在扫描区间插入新记录的可能。因此就解决了幻读的问题。<br>

上面说的只是一般情况下的加锁行为。一些特殊条件下，加锁行为是不同的。因为，总原则是能少加锁就少加锁，能不加锁就不加锁。<br>

- 如果搜索条件是主键/唯一二级索引跟常量的比较，且目标记录存在的情况下，只需要对改记录加 record 锁即可。因为这种情况下，因为键冲突的限制，只会存在这一条满足条件的记录，因此并不会出现幻读的问题。

- 对于精准匹配，对于扫描区间的最后一条记录，只需要加 gap 锁即可。

疑问：个人绝对，无论如何，扫描区间的最后一条记录都只需要加 gap 锁即可，没必要加 record 锁。因为及时这条记录发生变更，无论如何加不会加入到扫描区间中，因为我们已经枷锁了，所以不会产生幻读的可能。

# 死锁

死锁指的是资源的互相等待。在 InnoDB 中如果发生了死锁，该如何查找涉及死锁的事务都有哪些？发生死锁的时候，都在执行哪一条语句，都占据了哪些锁，在等待哪些锁？

在 mysql8 中，我们可以通过
```sql
SHOW ENGINE INNODB STATUS\G
```
查看死锁发生时的场景，在 `LATEST DETECTED DEADLOCK` 分节中。

该分节详细展示了发生死锁时都有哪些事务，正在执行那条语句，各自占有哪些锁，等待哪些锁，以及最后 InnoDB 决定回滚哪个事务。

需要注意的时，通过上述方式只能查找到最近一次死锁的场景。如果死锁频繁发生，可以打开系统变量 `innodb_print_all_deadlocks`，这样可以在错误日志中查看所有的死锁情况了。

另外，当我们打开系统变量`SET GLOBAL innodb_status_output_locks = ON;` 的时候，通过 `SHOW ENGINE INNODB STATUS\G` 可以查看每个事务详细的加锁情况(只有分配了事务 id 的事务才有记录。只有执行了增删改或者 for update 读的事务才会被分配事务 id)。