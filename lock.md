本文介绍 Innodb 中的锁。

# 表级锁

## MDL

MDL(MetaData Lock) 即元数据锁，该锁是在 mysql server 层中实现的一个锁，用来保护表元数据。ddl 语句会加 MDL 的互斥锁，而普通的 sql 语句都会加 MDL 的共享锁。

## IX/IS

IX 意向互斥锁，当要加记录的互斥锁的时候，就会加一个表级别的 IX 锁。
IS 意向共享锁，当要加记录的共享锁的时候，就会加一个表级别的 IS 锁。

那么 IX/IS 存在的意义是什么呢？

当我们要加表级别的共享锁的时候，我们需要确保当前表中没有记录的 X 锁，怎么判断呢？遍历吗？
当我们要加表级别的互斥锁的时候，我们需要确保当前表中没有记录的 X 锁 和 S 锁，怎么判断呢？遍历吗？

这就是 IX/IS 的作用，只需要判断当前表是否有 IX/IS，即可知道，当前表是否存在行维度的锁，提高了系统整体性能。

## AUTO_INC 锁

当表中有 AUTO_INCREMENT 字段，在插入数据的时候，就需要占据该锁获取新的值。

# 行锁

行锁是存储引擎维度的锁，**并不是所有的存储引擎都支持行锁**。

## record 锁

如果只对某条记录加锁，这就是 record 锁，有共享锁/互斥锁两种类型。

## gap 锁

gap 锁指的是对两条记录之间的区域加一个锁，禁止在该区域插入新的数据。需要特别注意的是，**即使某个事务加了 gap 锁，另一个事务还是可以加 gap 锁的， gap 锁存在的意义仅仅是为了避免插入新的数据，彼此之间是没有互斥性的**。

那么这个特殊的锁用于什么目的呢？禁止插入新的数据？为什么要禁止插入新的数据呢？ 为了解决 **幻读**。

## next-key 锁

next-key 锁就是 record 锁 + gap 锁。

# 不同隔离级别加锁行为分析

我们看看不同隔离级别下是怎么加锁的。不仅仅是锁定读语句，增、删、改语句在操作记录前，都有一个与锁定读语句类似的锁定的过程，而锁定的过程就是加锁的过程。

## 读提交

读提交隔离级别，主要避免不可重复读的问题。因此，会对扫描区间中所有符合条件的记录都加 record 锁，至于扫描区间中不符合条件的记录是不会加锁的，因此其他的事务可以修改这些记录，导致事务在下次以相同的条件锁定记录的时候可以得到新的记录，这就是幻读。

## 可重复读

与读提交隔离级别不同的是，可重复读隔离级别在锁定语句的时候，会对扫描区间中的所有记录都加 record + gap 锁，**不管记录是否满足条件**。 为什么这么做呢？gap 锁避免了其他事务在扫描区间插入新记录的可能。而对不满足条件的记录也加锁，避免了其他事务更改此记录，导致相同条件锁定到了新的记录的可能。因此就解决了幻读的问题。

上面说的只是一般情况下的加锁行为。一些特殊条件下，加锁行为是不同的。

比如，如果搜索条件是主键/唯一二级索引跟常量的比较，且目标记录存在的情况下，只需要对改记录加 record 锁即可。因为这种情况下，因为键冲突的限制，只会存在这一条满足条件的记录，因此并不会出现幻读的问题。

# 死锁

死锁指的是资源的互相等待。在 InnoDB 中如果发生了死锁，该如何查找涉及死锁的事务都有哪些？发生死锁的时候，都在执行哪一条语句，都占据了哪些锁，在等待哪些锁？

在 mysql8 中，我们可以通过
```sql
SHOW ENGINE INNODB STATUS\G
```
查看死锁发生时的场景，在 `LATEST DETECTED DEADLOCK` 分节中。

该分节详细展示了发生死锁时都有哪些事务，正在执行那条语句，各自占有哪些锁，等待哪些锁，以及最后 InnoDB 决定回滚哪个事务。

需要注意的时，通过上述方式只能查找到最近一次死锁的场景。如果死锁频繁发生，可以打开系统变量 `innodb_print_all_deadlocks`，这样可以在错误日志中查看所有的死锁情况了。
