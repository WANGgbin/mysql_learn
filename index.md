描述 InnoDB 中 B+ 索引的工作原理.

## B+ 树索引
- B+ 树是什么? 

作为一个存储引擎, 查询数据的速度一定要足够的快. 索引就是用来快速定位一条消息的. 那么索引的工作原理又是什么呢?

对于一串数据, 怎么能够快速的定位一条记录呢? 本质上就是 **排序 + 分组** 的方式, 首先快速定位到某个区间或者某个组, 然后在这个组再进行查找.
不管是有序数组的二分查找 还是 链表的跳表, 又或者是红黑树, AVL, 本质上就是上述 **排序+ 分组** 思想的实现方式.

B+ 树本质上就是个多路查找树. 

- 为什么采用 B+ 树而不是 B 树?

  B 树的记录可能存储在非叶子页中， 这就会导致 B 树层级比 B+ 高。 B+ 树相比 B 树而言优势为：
  - 更低的层级， 更好的性能
  - 因为 B+ 树中， 所有记录都在叶子页面，因此查询性能更加稳定
  - 因为 B+ 树所有的叶子页面都是串联在一起的，当按照索引找到第一条记录的时候， 便可以沿着页列表依次判断接下来的记录是否满足条件，直到遇到不满足条件的记录，查询结束。 但是 B树的记录并没有这样的特性。

## 创建/删除索引

CREATE TABLE 表名 (
    各个列信息,
    (KEY|INDEX) 索引名 (单个列/多个列)
);

ALTER TABLE 表名 ADD (KEY|INDEX) 索引名 (单个列/多个列);
ALTER TABLE 表名 DROP (KEY|INDEX) 索引名;

索引的名字最好以 `idx_` 为前缀，后面跟着以 _ 为间隔的索引列名字。

## 主键索引


主键索引又称为一级索引. InnoDB 的用户数据就存储在主键索引的叶子页面上. 非叶子页面中存储所谓的目录项记录, 每一条目录项记录, 只存储**主键 + 页号**.

## 二级索引

之所以称为二级索引是因为通过该索引无法直接查找到记录的全部数据, 只能查询到记录对应的主键, 还需要回表才能查找到记录的全部信息, 因此被称为二级索引.与主键索引不同, 二级索引的叶子页面中只存储**二级索引列 + 主键**, 非叶子页面中存储**二级索引列 + 主键 + 页号**. 本质上来说，**二级索引是 "二级索引列 + 主键" 形成的 唯一索引**。

## 回表

什么是回表, 回表指的是通过二级索引查询到记录的主键后, 还需要通过主键索引查找才能查找到记录的全部信息. 这个行为称之为回表. 回表有什么代价吗?
通常 我们通过二级索引叶子页面中的主键都是随机的, 只有二级索引对应的列是按序排列的. 因此,回表操作基本上就是 **随机 I/O**, 这会带来性能的损耗.

## 索引覆盖

什么是索引覆盖? 如果二级索引能够覆盖我们要查询的字段, 这要就不需要回表, 这称之为索引覆盖. 比如, 如果只通过二级索引查询主键, 就不需要回表.
## 索引下推

当通过二级索引查询到某条记录后, 通常还需要回表查询到记录的全部信息才能判断当前这条记录是否满足用户的查询条件. 如果, 查询条件中的某个字段被二级索引覆盖, 且该字段不满足查询条件, 这样我们也没必要再次回表了.
这称之为索引下推.

## 索引最左前缀


## 联合索引

我们可以使用几个列建立一个索引, 这个索引称之为联合索引.

## 索引越多越好吗?
 
索引并不是越多越好, 从空间角度而言, 索引需要占据额外的磁盘空间. 从时间角度而言, 记录的增/删/改操作, 都需要更改每一个索引中对应的记录. 另外, 优化器在生成一条语句的执行计划的时候, 首先会进行成本分析, 成本分析会遍历每一个列, 来计算成本, 这也会加剧性能的劣化.

## 更好地创建和使用索引

- 只为用于搜索,分组,排序的字段创建索引

并不是索引越多越好, 只在必要的字段上建立索引, 比如查询, 排序, 分组.

- 考虑索引列中不重复值的个数

如果一个索引列中的字段很多值都是相同的, 这样索引也就无法帮助我们减少更多的行. 同时可能会进行大量的回表操作, 影响程序性能, 此类字段是不建议建立索引的.

- 索引列的类型尽量小

为什么? 因为索引列类型尽量的小, 一个页中也就能存储更多的记录, 这样整个 B+ 树层级更低, 查询性能更高, 尤其是主键字段, 因为主键字段还用于其他的二级索引.

- 为列前缀建立索引

当某个列可能很长的时候，如果直接对该列创建索引就会导致 B+ 树层级过高，从而影响查询性能。我们可以只对该列的前缀建立索引，那么这里前缀应该设计多长呢？ 太短的话，会导致重复度太高，也会影响性能，太长的话，又会出现前面的情况。

- 覆盖索引

我们可以优化查询语句, 在满足业务的条件下, 尽可能的使用到覆盖索引, **不要一股闹的使用\***

- 索引列名在搜索条件中单独出现

InnoDB 并不是足够只能， 我们应该尽量让索引列在搜寻条件中单独出现， 这样就可以使用到索引。比如：
**where index_col < 2/4; 而不是 where index_col * 4 < 2**


- 新插入记录主键大小最效率的影响                                  

新插入记录的主键最好是按序增加的，这样可以避免不必要的页分裂。页分裂指的是分配一个新的磁盘页，并拷贝部分数据到这个页， 这会带来两个问题：
  - 磁盘空间浪费
  - 页内部碎片

因此，新插入记录的主键最好是按序增加的。使用 `AUTO_INCREMENT` 就是最佳实践。 

- 冗余和重复索引

尽量避免创建重复索引，尤其是在已经建立了联合索引的条件之下。