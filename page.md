描述 mysql 中磁盘页的构造.

磁盘页用于存储 mysql 中的数据, 实际上, mysql 中真正跟磁盘交互的是存储引擎, 因此不同的存储引擎对应的磁盘页的格式也是不同的, 甚至有的存储引擎将数据存储在内存中, 比如 MEMORY. 
因为 InnoDB 是 mysql 的默认存储引擎, 因此我们只关注 InnoDB 对应的磁盘页的构造.

## 页

系统变量 `innodb_page_size` 表明了 InnoDB 页的大小, 默认值为 16384, 单位为字节, 即 16kb. InnoDB 跟磁盘交互的基本单位就是页, 也就是说每次读写至少是一个页.

## 记录

表的每一行记录在磁盘页中到底是怎么存储的呢?
目前为止, InnoDB 规定了 4 种行格式, 即: `COMPACT`, `REDUNDANT`, `DYNAMIC`, `COMPRESSED`. 其中, REDUNDANT 格式比较旧了, 我们重点关注其他三种格式的日志.

### 行格式

- COMPACT

COMPACT 即 紧凑的意思, 采用最少的空间来存储记录. 那么通过哪些方法降低了空间的使用呢?
  - 变长字段长度列表

    对于变长字段, 只需要存储字段的实际长度即可. 每一行除了记录真实数据外, 还存储了一些额外信息, 额外信息部分分为三个字段. 其中, 第一个字段为变长字段长度列表, 即存储每个变长且值非空的字段的实际长度.

  - NULL 值列表

    额外信息的第二个字段表示一个位图, 对于每一个可以为 NULL 的列, 都对应一个位, 0 表示当前值为 NULL, 1 表示非空.

    通过变长字段长度列表和空值列表这两个信息, 结合表字段的定义, 我们就可以获取每个值非空且变长的字段的实际长度.

  - 记录头信息

    除此之外, 记录头信息还存储了一些行的额外信息, 主要包括 n_owned, next_record, deleted_flag 等. 其中 n_owned, next_record, 用来将一个页中的记录根据主键大小有序串联起来, 后面在介绍如何在一个页中查找记录的时候, 会介绍这几个字段的含义. deleted_flag 用于标记当前字段是否删除, 本质是个软删除标记, 用于 MVCC. 

每一行除了上述三部分信息外, 剩下的内容就是行的实际信息. 实际上, 为了支持 MVCC 和 回滚, 每一行被 InnoDB 额外注入了两个字段: `trx_id` 和 `roll_pointer`, trx_id 用来表示事务 id, roll_pointer 指向版本链. 在后面介绍回滚和 MVCC 的时候, 还会详细介绍这两个字段. 除了这两个字段, 当 表没有定义主键且没有不为 NULL 的唯一索引的时候, InnoDB 还会注入一个 row_id 列, 用来唯一标识当前行. 至于 row_id 列的值是怎么生成的, 实际上, InnoDB 维护了一个全局的 MAX_ROW_ID, 存储在系统表空间中, 所有的表都共享这个字段, row_id 列的值就来自于这个字段.

- DYNAMIC

 DYNAMIC 的格式跟 COMPACT 的格式是很类似的, 除了处理 `溢出列` 不同. 什么是溢出列呢?
 当某一列的长度很长的时候, 记录中并不会存储字段的全部信息, 额外的信息会被存储到单独的页中, 这些页被称为溢出页. COMPACT 格式下, 溢出列会存储部分信息+溢出页号, 而 DYNAMIC 格式下记录只存储溢出页号, 溢出列所有的信息都存储在溢出页中.

- COMPRESSED

COMPRESSED 采用了压缩算法, 对行记录进行了压缩.

- 指定表的行格式

那么我们该如何制定表的行格式呢? 两种方式:
  - `ALTER TABLE xxx ROW_FORAMT=xxx;`
  - `CREATE TABLE xxx () ROW_FORMAT=xxx;`

### page directory(页目录)

在页中, 记录之间紧密相邻. 现在的问题是, 当我们要查找某一条记录的时候, 怎么快速查找呢?
记录之间通过主键的大小进行了排序, 彼此之间通过 `next_record` 字段连接在一起, 形成一个单链表. 当我们查找某个记录的时候, 只能遍历这个单链表吗? 不, 这样性能太低. InnoDB 引入了 page directory 的概念, 本质上来说就是把记录分成了若干组, 然后将每一个组中最后一条记录在页中的偏移量作为一个 slot 记录在 page directory 中, page directory 中的 slots 是有序的. 而 n_owned 字段则表示当前组中有多少条记录.

这样当我们查找某个记录的时候, 首先通过 **二分查找** 的方式在 page directory 中定位对应的 slot, 然后再根据 next_record 遍历该组中的每一条记录来寻找目标记录. 当我们要插入一条新的记录的时候, 查询过程也是类似的.

我们要多学习 page directory 的这种思想. 本质上就是通过索引的方式,将查找范围缩小到一个特定区间, 然后再遍历该区间. 实际上在 kafka 中, index 文件起到跟这里的 page directory 相同的作用, 都是先快速限定一个较小的区间, 然后再遍历.

### page header(页头部)

页头部存储了一些记录的全局信息, 包括多少条记录, page directory 中有多少个 slot, 当前页的 free space 首地址, 删除链表首记录对应的地址 等. 还有一些跟 B+ 树相关的信息, 比如当前页在 B+ 树中的层级, 当当前页是 B+ 树的根的时候, 还会记录叶子节点和非叶子节点对应的段在什么地方.

### file header(文件头部)

所有的页都有 file header, 我们只描述里面的一些关键字段:
- 页的校验和
- 页号
- InnoDB 中经常会出现将一些页串联成链表的场景, 而 `FIL_PAGE_PREV` 和 `FIL_PAGE_NEXT` 分别表示链表的前后页号.
- 页的类型

### 其他问题

- 当删除某一行的时候, 空闲的空间是怎么管理的?

当物理删除一行记录的时候, 就会把当前记录加到当前页的删除列表中. 当下次插入新的记录的时候, 如果大小合适, 就可以复用该删除列表中的空间.

- 当更改某一行的时候, 比如增大某个字段值的长度, 在页中又发生了什么?

删除原来的记录, 并插入一条新的记录.