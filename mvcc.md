什么是 mvcc 呢？

mvcc 是 多版本并发控制的简称。用于在读提交、可重复读隔离级别下的快照读。

# mvcc 工作原理

我们知道当事务修改了数据后，生成的新的记录会有一个 `roll_pointer` 字段指向旧的数据, 从而所有历史的数据(实际上会清理不再使用的历史版本数据)组成了一个版本链。

该版本链除了用于事务的回滚外，另一个重要的用途就是 mvcc.

mvcc 主要用于读提交、可重复读隔离级别下的读写并发控制，当某个事务写数据的时候，另一个事务可以同时读数据而不需要等待写事务执行完毕后才读数据，从而提高了事务的并发度，提高了系统的整体性能。

那么 mvcc 到底是怎么实现的呢？

## read view

read view 指的是一致性视图，当某个事务读数据前，会生成一个当前系统中事务的视图，其中包括：
- 活跃事务中的最小事务 id
- 下一个要分配的事务 id
- 上述两个事务 id 区间中已提交的事务 id 集合

当事务开始读取记录的时候，会判断该记录的 trx_id 对应的事务是否已经提交或者是否是自己的事务，如果是则直接读取。否则会沿着记录的版本链持续寻找，直到找到满足条件的记录或者找不到记录。

而读提交隔离级别 和 可重复读隔离级别的不同仅仅在于 **一致性视图生成的时机不同**。

- 读提交隔离级别

    在执行每一条读语句的时候，都会重新生成一致性视图。

- 可重复读隔离级别

    只有在执行第一条读语句的时候，才会生成一致性视图，后续所有的 mvcc 操作都基于该一致性视图。mvcc 是怎么解决幻读的问题的呢？因为在事务执行过程中，其他新提交的事务的修改(增、删、改)对该事务都是不可见的，因此相同的查询条件，得到的记录数量是相同的。

    但，我们之前说 mvcc + 可重复读 可以很大程度避免幻读的发生，什么时候会发生幻读呢？

    考虑以下 sql 语句:
    ```sql
    -- 首先我们建个 hero 表
    create table hero (
        id int not null auto_increment,
        name varchar(10) not null,
        country varchar(10) not null,
        primary key(id),
        index idx_name(name)
    )engine=innodb;

    -- 接着插入一条语句
    insert into hero (name, country) values('曹操', '魏');

    -- 开启一个事务，读表中全部数据
    start transaction;
    select * from hero;

    -- 得到的结果只有一条记录
    /*
    +----+------+---------+
    | id | name | country |
    +----+------+---------+
    |  1 | 曹操 | 魏      |
    +----+------+---------+
    */

    -- 此时开启另一个会话插入一条新的记录
    insert into hero (name, country) values('孙权', '吴');

    -- 此时，再次读取全部记录，还是只有一条记录，因为 mvcc 的原因，两一个会话插入的记录被忽略。

    -- 重点来了，此时我们修改 id = 2 的数据。后面会介绍，update 语句并不会使用 mvcc 而是锁，只要能获取锁就是可见。
    update hero set country='魏' where id = 2;

    -- 再次查询，这个时候我们读到了两条数据，即发生了幻读，为什么？因为上述的 update 语句将记录的 trx_id 修改为了自己的事务 id，因此可见。
    /*
    +----+------+---------+
    | id | name | country |
    +----+------+---------+
    |  1 | 曹操 | 魏      |
    |  2 | 孙权 | 魏      |
    +----+------+---------+
    */
    ```

# 什么时候不会使用 mvcc

既然 mvcc 相对于加锁而言，性能更好，为什么还要存在加锁这种方式呢？

- 并不是所有操作都使用 mvcc

    我们知道只有在读提交、可重复读隔离级别下的读操作才会使用 mvcc，而增、删、改，涉及到写操作都是加锁。

- 并不是所有的读操作都使用 mvcc

    假设某些场景下，**我们就想读取最新的数据**，那么读数据的时候就需要加锁。我们把这种加锁的读称为加锁读，语法为：
    ```sql
    select * from table for update; -- 加互斥锁
    select * from table lock in share mode; -- 加共享锁
    ```