描述 mysql 中的事务。

# 事务的特性
什么是事务呢？英文为 `transaction`，即交易的意思。在一场交易中，有买有卖，我们不希望发生有买无卖或者有卖无买的现象，要么都发生，要么都没发生。

而事务跟一场交易很相似，事务是若干操作的集合，事务通常具有以下特性。

- A(Atomic)

    A 即事务的原子性，要么都执行，要么都不执行，不允许只执行一半的情况出现。

- I(Isolation)

    I 即事务的隔离性，在高并发的场景下，会出现多个同时允许的事务，我们需要控制事务之间的影响级别，即事务的隔离级别。

- D(Duration)

    D 即事务的持久性，一旦事务执行成功，事务的结果就永久生效。

- C(Consistent)

    C 即事务的一致性，实际上上述几个特性都是为了 C 服务的。怎么理解一致性呢？一致性代表的是一种状态，这种状态应该满足一定的约束，或者说该状态是正确的，至于这种约束到底是什么，需要看具体的场景，不同的场景定义不同。数据库只能从一个一致性的状态转移到另一个一致性的状态。

# 事务的隔离级别

为什么要隔离事务呢？因为若干个事务并发执行的时候，会发生各种各样的问题。常见的问题有：
- 脏写

    如果两个事务同时写某个 record，就会发生脏写的问题。

- 脏读

    如果某个事务修改了某条记录但是还没提交，就发生了脏读的问题，即读未提交。

- 不可重复读

    某个事务按照相同查询条件得到了不同的数据，这里的不同数据，特指原先满足条件的记录的内容发生了变化。

- 幻读

    幻读特指同一个事务中相同的查询条件，得到了新的记录/少了记录。可能是因为其他事务插入了新的记录或者更改了某个记录使得该记录满足查询条件或者是删除了某个满足条件的记录，导致记录的数量发生了不同。

那么事务的隔离级别都有哪些呢？

- read uncommited (读未提交)

    可以直接读未提交事务的修改。此隔离级别会发生脏读、不可重复读、幻读。

- read commited (读提交)

    只能读取已提交的事务的更改，此隔离级别会发生不可重复读、幻读的问题。

- repeatable read (可重复读)

    此隔离级别会发生幻读的问题。

- serializable (串行)

    最严格的隔离级别，表示事务只能串行执行。这种隔离级别事务之间互不影响，但是并发度最低，性能最差。

> 需要注意的是，以上的隔离级别只是 sql 的标准，不同的数据库对隔离级别的实现是不尽相同的。比如 oracle 只实现了 read commited 和 serializable 两种隔离级别，而 mysql 在 repeated read 隔离级别下，在 使用 mvcc 的时候可以很大程度避免幻读的问题，而在加锁的方式下，可以完全避免幻读的问题。

# 分布式事务

- 什么是分布式事务

    又称全局事务/大事务，由若干个本地事务组成。比如：在多个 mysql 节点上的事务。

- 怎么实现？

    - XA 规范

        首先两个角色：
        - 事务协调器

            统筹兼顾各个事务，通常是事务发起者，比如客户端。

        - 事务管理器

            本地事务的管理者，否则本地事务的执行/提交/回滚。

        XA 规范，将整个事务的提交分为 prepare + commit 两个阶段。为什么要有  prepare 阶段呢？

        - 如果直接是 commit 阶段，如果某个本地事务 commit 发生错误了，其他已提交的事务无法回滚，违背事务的原子性。
        - prepare 阶段，也称为预提交阶段。 完成一些预提交操作(比如将 redo_log 刷盘)，尽可能将提交时候可能发生的错误提前暴露出去。


    那么如果 prepare 之后的 commit 阶段系统崩溃，不也是出现部分提交，部分未提交的情况吗？实际上，因为在 prepare 阶段已经将 redo_log 刷盘了，所以在 commit 阶段即使服务崩溃重启，也可以恢复到 prepare 阶段的状态，然后决定提交/回滚。

# 内部 XA

两种场景：

- 多个支持事务的存储引擎的原子提交
- bin log 刷盘与事务提交的原子性
    我们知道当 sync_binlog 选项打开的时候，mysql 在事务提交的时候，同时会将 bin log 刷盘。那么事务提交 + bin log 刷盘，如何保证原子性呢？这就涉及到内部 XA。<br>

内部 XA 同样分两个阶段，prepare + commit。


