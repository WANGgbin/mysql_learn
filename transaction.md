描述 mysql 中的事务。

# 事务的特性
什么是事务呢？英文为 `transaction`，即交易的意思。在一场交易中，有买有卖，我们不希望发生有买无卖或者有卖无买的现象，要么都发生，要么都没发生。

而事务跟一场交易很相似，事务是若干操作的集合，事务通常具有以下特性。

- A(Atomic)

    A 即事务的原子性，要么都执行，要么都不执行，不允许只执行一半的情况出现。

- I(Isolation)

    I 即事务的隔离性，在高并发的场景下，会出现多个同时允许的事务，我们需要控制事务之间的影响级别，即事务的隔离级别。

- D(Duration)

    D 即事务的持久性，一旦事务执行成功，事务的结果就永久生效。

- C(Consistent)

    C 即事务的一致性，实际上上述几个特性都是为了 C 服务的。怎么理解一致性呢？一致性代表的是一种状态，这种状态应该满足一定的约束，或者说该状态是正确的，至于这种约束到底是什么，需要看具体的场景，不同的场景定义不同。数据库只能从一个一致性的状态转移到另一个一致性的状态。

# 事务的隔离级别

为什么要隔离事务呢？因为若干个事务并发执行的时候，会发生各种各样的问题。常见的问题有：
- 脏写

    如果两个事务同时写某个 record，就会发生脏写的问题。

- 脏读

    如果某个事务修改了某条记录但是还没提交，就发生了脏读的问题，即读未提交。

- 不可重复读

    某个事务按照相同查询条件得到了不同的数据，这里的不同数据，特指原先满足条件的记录的内容发生了变化。

- 幻读

    幻读特指同一个事务中相同的查询条件，得到了新的记录/少了记录。可能是因为其他事务插入了新的记录或者更改了某个记录使得该记录满足查询条件或者是删除了某个满足条件的记录，导致记录的数量发生了不同。

那么事务的隔离级别都有哪些呢？

- read uncommited (读未提交)

    可以直接读未提交事务的修改。此隔离级别会发生脏读、不可重复读、幻读。

- read commited (读提交)

    只能读取已提交的事务的更改，此隔离级别会发生不可重复读、幻读的问题。

- repeatable read (可重复读)

    此隔离级别会发生幻读的问题。

- serializable (串行)

    最严格的隔离级别，表示事务只能串行执行。这种隔离级别事务之间互不影响，但是并发度最低，性能最差。

> 需要注意的是，以上的隔离级别只是 sql 的标准，不同的数据库对隔离级别的实现是不尽相同的。比如 oracle 只实现了 read commited 和 serializable 两种隔离级别，而 mysql 在 repeated read 隔离级别下，在 使用 mvcc 的时候可以很大程度避免幻读的问题，而在加锁的方式下，可以完全避免幻读的问题。

# 分布式事务